import { validate } from "class-validator";
import { PmmOrderbookItem } from "../../src/dtos/orderbook.dto";
import { plainToInstance } from "class-transformer";
import { PmmService } from "../../src/services/pmm.service";
import {
  chainId,
  sellerToken,
  buyerToken,
  signer,
  poolAddresses,
} from "../../template/rest.config";
import {
  GetPmmFirmQuoteDto,
  PmmFirmQuoteData,
} from "../../src/dtos/firmQuote.dto";
import { randomUUID } from "crypto";
import {
  GetPmmSignQuoteDto,
  PmmSignQuoteData,
  SignedOrderStruct,
} from "../../src/dtos/signQuote.dto";
import { recoverRFQTSignature } from "../../src/utils/helpers";

const pmmService = new PmmService();
const constraints = {
  whitelist: true,
  forbidNonWhitelisted: true,
};
const sellerTokenAmount = "10000000";

/*
Do not edit this file
Edit params via integration_tests/template/rest.config.ts
*/
describe("REST API Integration Tests with gw", () => {
  describe("Orderbook API Tests", () => {
    it("Validate successful Orderbook response structure ", async () => {
      const orderbook = await pmmService.callOrderbook({ chainId });
      const result = plainToInstance(
        PmmOrderbookItem,
        orderbook.data as PmmOrderbookItem[]
      );
      const validationErrors = await Promise.all(
        result.map((item) => validate(item, constraints))
      );
      const errors = validationErrors.filter((error) => error.length > 0);

      expect(errors.length).toBe(0);
      expect(orderbook.success).toBe(true);
      expect(orderbook.data.length).toBeGreaterThan(0);
      expect(orderbook.error).toBeUndefined();
    });
  });

  describe("Firm Quote API Tests", () => {
    it("Validate successful Firm Quote response structure", async () => {
      const params: GetPmmFirmQuoteDto = {
        chainId: chainId,
        sellerTokenAmount: sellerTokenAmount,
        sellerToken: sellerToken,
        buyerToken: buyerToken,
        pool: poolAddresses[chainId],
        seller: "0xDB714C6c6bd7D1bab01C8E8787f41a8E6B9F2d0c",
        beneficiary: "0xDB714C6c6bd7D1bab01C8E8787f41a8E6B9F2d0c",
        quoteId: randomUUID(),
        feeBps: 10,
        availableBorrowBalance: "100000000",
      };
      const firmQuote = await pmmService.callFirmQuote(params);
      const result = plainToInstance(
        PmmFirmQuoteData,
        firmQuote.data as PmmFirmQuoteData
      );
      const validationErrors = await validate(result, constraints);

      expect(validationErrors.length).toBe(0);
      expect(firmQuote.success).toStrictEqual(true);
      expect(firmQuote.data).toBeDefined();
      expect(firmQuote.data.deadlineTimestamp).toBeLessThan(
        Math.floor(Date.now() / 1000) + 121 //1 second buffer
      );
      expect(firmQuote.error).toBeUndefined();
    });

    it("Different seller and beneficiary should return success", async () => {
      const params: GetPmmFirmQuoteDto = {
        chainId: chainId,
        sellerTokenAmount: sellerTokenAmount,
        sellerToken: sellerToken,
        buyerToken: buyerToken,
        pool: poolAddresses[chainId],
        seller: "0x54083336251a609e79c7f8ebb6180b7ef5f96402",
        beneficiary: "0xDB714C6c6bd7D1bab01C8E8787f41a8E6B9F2d0c",
        quoteId: randomUUID(),
        quoteExpiry: 0,
        feeBps: 0,
        availableBorrowBalance: "100000000",
      };
      const firmQuote = await pmmService.callFirmQuote(params);
      const result = plainToInstance(
        PmmFirmQuoteData,
        firmQuote.data as PmmFirmQuoteData
      );
      const validationErrors = await validate(result, constraints);

      expect(validationErrors.length).toBe(0);
      expect(firmQuote.success).toStrictEqual(true);
      expect(firmQuote.data).toBeDefined();
      expect(firmQuote.data.deadlineTimestamp).toBeGreaterThan(
        Math.floor(Date.now() / 1000)
      );
      expect(firmQuote.error).toBeUndefined();
    });
  });

  describe("Sign Quote API Tests", () => {
    it("Validate successful Sign Quote response structure and signature", async () => {
      const quoteId = randomUUID();
      const nonce = 8020303003020032;
      const firmQuoteParams: GetPmmFirmQuoteDto = {
        chainId: chainId,
        sellerTokenAmount: sellerTokenAmount,
        sellerToken: sellerToken,
        buyerToken: buyerToken,
        pool: poolAddresses[chainId],
        seller: "0xDB714C6c6bd7D1bab01C8E8787f41a8E6B9F2d0c",
        beneficiary: "0xDB714C6c6bd7D1bab01C8E8787f41a8E6B9F2d0c",
        quoteId: quoteId,
        feeBps: 10,
        quoteExpiry: 20,
        availableBorrowBalance: "0",
      };
      const { data: firmQuoteData } = await pmmService.callFirmQuote(
        firmQuoteParams
      );

      const signQuoteParams: GetPmmSignQuoteDto = {
        nonce: nonce,
        signer: signer,
        chainId: chainId,
        sellerTokenAmount: sellerTokenAmount,
        buyerTokenAmount: firmQuoteData.buyerTokenAmount,
        sellerToken: sellerToken,
        buyerToken: buyerToken,
        seller: "0xDB714C6c6bd7D1bab01C8E8787f41a8E6B9F2d0c",
        buyer: poolAddresses[chainId], //gw pool address
        quoteId: quoteId,
        deadlineTimestamp: firmQuoteData.deadlineTimestamp,
        auth: firmQuoteData.auth,
        txOrigin: "0xDB714C6c6bd7D1bab01C8E8787f41a8E6B9F2d0c",
      };
      const signQuote = await pmmService.callSignQuote(signQuoteParams);
      const [dataResult, orderResult] = [
        plainToInstance(PmmSignQuoteData, signQuote.data as PmmSignQuoteData),
        plainToInstance(
          SignedOrderStruct,
          signQuote.data.order as SignedOrderStruct
        ),
      ];
      const [dataValidationErrors, orderValidationErrors] = [
        await validate(dataResult, constraints),
        await validate(orderResult, constraints),
      ];

      expect(dataValidationErrors.length).toBe(0);
      expect(orderValidationErrors.length).toBe(0);
      expect(signQuote.success).toStrictEqual(true);
      expect(signQuote.data).toBeDefined();
      expect(signQuote.data.order.id).toStrictEqual(nonce);
      expect(signQuote.data.order.buyerToken).toStrictEqual(buyerToken);
      expect(signQuote.data.order.sellerToken).toStrictEqual(sellerToken);
      expect(signQuote.data.order.sellerTokenAmount).toStrictEqual(
        sellerTokenAmount
      );
      expect(signQuote.data.order.buyerTokenAmount).toStrictEqual(
        firmQuoteData.buyerTokenAmount
      );
      expect(signQuote.data.order.caller).toStrictEqual(
        signQuote.data.order.seller
      );
      expect(signQuote.data.order.quoteId).toStrictEqual(
        firmQuoteParams.quoteId
      );
      expect(String(signQuote.data.order.deadlineTimestamp)).toStrictEqual(
        String(firmQuoteData.deadlineTimestamp)
      );
      expect(signQuote.error).toBeUndefined();

      const recoveredSignerAddress = await recoverRFQTSignature(
        signQuote.data as PmmSignQuoteData
      );
      expect(recoveredSignerAddress.toLowerCase()).toStrictEqual(
        signQuoteParams.signer.toLowerCase()
      );
    });
  });
});
